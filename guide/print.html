<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Actix web</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Actix web framework guide">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('mdbook-theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('mdbook-sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li class="affix"><a href="./qs_1.html">Quickstart</a></li><li><a href="./qs_2.html"><strong>1.</strong> Getting Started</a></li><li><a href="./qs_3.html"><strong>2.</strong> Application</a></li><li><a href="./qs_4.html"><strong>3.</strong> Handler</a></li><li><a href="./qs_4_5.html"><strong>4.</strong> Errors</a></li><li><a href="./qs_6.html"><strong>5.</strong> State</a></li><li><a href="./qs_5.html"><strong>6.</strong> Resources and Routes</a></li><li><a href="./qs_7.html"><strong>7.</strong> Request &amp; Response</a></li><li><a href="./qs_9.html"><strong>8.</strong> WebSockets</a></li><li><a href="./qs_10.html"><strong>9.</strong> Middlewares</a></li><li><a href="./qs_12.html"><strong>10.</strong> Static file handling</a></li><li><a href="./qs_13.html"><strong>11.</strong> HTTP/2</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars" title="Toggle sidebar"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush" title="Change theme"></i>
                    </div>

                    <h1 class="menu-title">Actix web</h1>

                    <div class="right-buttons">
                        <a href="print.html">
                            <i id="print-button" class="fa fa-print" title="Print this book"></i>
                        </a>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="print.html#quickstart" id="quickstart"><h1>Quickstart</h1></a>
<p>Before you can start writing a actix web application, you’ll need a version of Rust installed.
We recommend you use rustup to install or configure such a version.</p>
<a class="header" href="print.html#install-rust" id="install-rust"><h2>Install Rust</h2></a>
<p>Before we begin, we need to install Rust using the <a href="https://www.rustup.rs/">rustup</a> installer:</p>
<pre><code class="language-bash">curl https://sh.rustup.rs -sSf | sh
</code></pre>
<p>If you already have rustup installed, run this command to ensure you have the latest version of Rust:</p>
<pre><code class="language-bash">rustup update
</code></pre>
<p>Actix web framework requies rust version 1.20 and up.</p>
<a class="header" href="print.html#running-examples" id="running-examples"><h2>Running Examples</h2></a>
<p>The fastest way to start experimenting with actix web is to clone the actix web repository
and run the included examples in the examples/ directory. The following set of
commands runs the <code>basic</code> example:</p>
<pre><code class="language-bash">git clone https://github.com/actix/actix-web
cd actix-web
cargo run --example basic
</code></pre>
<p>Check <code>examples/</code> directory for more examples.</p>
<a class="header" href="print.html#getting-started" id="getting-started"><h1>Getting Started</h1></a>
<p>Let’s create and run our first actix web application. We’ll create a new Cargo project
that depends on actix web and then run the application.</p>
<p>In previous section we already installed required rust version. Now let's create new cargo projects.</p>
<a class="header" href="print.html#hello-world" id="hello-world"><h2>Hello, world!</h2></a>
<p>Let’s write our first actix web application! Start by creating a new binary-based
Cargo project and changing into the new directory:</p>
<pre><code class="language-bash">cargo new hello-world --bin
cd hello-world
</code></pre>
<p>Now, add actix and actix web as dependencies of your project by ensuring your Cargo.toml
contains the following:</p>
<pre><code class="language-toml">[dependencies]
actix = &quot;0.3&quot;
actix-web = { git = &quot;https://github.com/actix/actix-web&quot; }
</code></pre>
<p>In order to implement a web server, first we need to create a request handler.</p>
<p>A request handler is a function that accepts a <code>HttpRequest</code> instance as its only parameter
and returns a type that can be converted into <code>HttpResponse</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix_web;
# use actix_web::*;
  fn index(req: HttpRequest) -&gt; &amp;'static str {
      &quot;Hello world!&quot;
  }
# fn main() {}
</code></pre></pre>
<p>Next, create an <code>Application</code> instance and register the
request handler with the application's <code>resource</code> on a particular <em>HTTP method</em> and <em>path</em>::</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix_web;
# use actix_web::*;
# fn index(req: HttpRequest) -&gt; &amp;'static str {
#    &quot;Hello world!&quot;
# }
# fn main() {
   let app = Application::new(&quot;/&quot;)
       .resource(&quot;/&quot;, |r| r.method(Method::GET).f(index))
       .finish();
# }
</code></pre></pre>
<p>After that, application instance can be used with <code>HttpServer</code> to listen for incoming
connections:</p>
<pre><code class="language-rust ignore">   HttpServer::new(app).serve::&lt;_, ()&gt;(&quot;127.0.0.1:8088&quot;);
</code></pre>
<p>That's it. Now, compile and run the program with cargo run.
Head over to <code>http://localhost:8088/</code> to see the results.</p>
<p>Here is full source of main.rs file:</p>
<pre><pre class="playpen"><code class="language-rust">extern crate actix;
extern crate actix_web;
use actix_web::*;

fn index(req: HttpRequest) -&gt; &amp;'static str {
    &quot;Hello world!&quot;
}

fn main() {
    let sys = actix::System::new(&quot;example&quot;);

    HttpServer::new(
        Application::new(&quot;/&quot;)
            .resource(&quot;/&quot;, |r| r.f(index)))
        .serve::&lt;_, ()&gt;(&quot;127.0.0.1:8088&quot;).unwrap();

    println!(&quot;Started http server: 127.0.0.1:8088&quot;);
#     actix::Arbiter::system().send(actix::msgs::SystemExit(0));
    let _ = sys.run();
}
</code></pre></pre>
<p>Note on <code>actix</code> crate. Actix web framework is built on top of actix actor library.
<code>actix::System</code> initializes actor system, <code>HttpServer</code> is an actor and must run within
proper configured actix system. For more information please check
<a href="https://actix.github.io/actix/actix/">actix documentation</a></p>
<a class="header" href="print.html#application" id="application"><h1>Application</h1></a>
<p>Actix web provides some primitives to build web servers and applications with Rust.
It provides routing, middlewares, pre-processing of requests, and post-processing of responses,
websocket protcol handling, multipart streams, etc.</p>
<p>All actix web server is built around <code>Application</code> instance.
It is used for registering handlers for routes and resources, middlewares.
Also it stores applicationspecific state that is shared accross all handlers
within same application.</p>
<p>Application acts as namespace for all routes, i.e all routes for specific application
has same url path prefix:</p>
<pre><code class="language-rust ignore"># extern crate actix_web;
# extern crate tokio_core;
# use actix_web::*;
# fn index(req: HttpRequest) -&gt; &amp;'static str {
#    &quot;Hello world!&quot;
# }
# fn main() {
   let app = Application::new(&quot;/prefix&quot;)
       .resource(&quot;/index.html&quot;, |r| r.method(Method::GET).f(index))
       .finish()
# }
</code></pre>
<p>In this example application with <code>/prefix</code> prefix and <code>index.html</code> resource
get created. This resource is available as on <code>/prefix/index.html</code> url.</p>
<p>Multiple applications could be served with one server:</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix_web;
# extern crate tokio_core;
use std::net::SocketAddr;
use actix_web::*;
use tokio_core::net::TcpStream;

fn main() {
    HttpServer::&lt;TcpStream, SocketAddr, _&gt;::new(vec![
        Application::new(&quot;/app1&quot;)
            .resource(&quot;/&quot;, |r| r.f(|r| httpcodes::HTTPOk)),
        Application::new(&quot;/app2&quot;)
            .resource(&quot;/&quot;, |r| r.f(|r| httpcodes::HTTPOk)),
        Application::new(&quot;/&quot;)
            .resource(&quot;/&quot;, |r| r.f(|r| httpcodes::HTTPOk)),
    ]);
}
</code></pre></pre>
<p>All <code>/app1</code> requests route to first application, <code>/app2</code> to second and then all other to third.</p>
<a class="header" href="print.html#handler" id="handler"><h1>Handler</h1></a>
<p>A request handler can by any object that implements
<a href="../actix_web/dev/trait.Handler.html#implementors"><code>Handler</code> trait</a>.
Request handling happen in two stages. First handler object get called.
Handle can return any object that implements
<a href="../actix_web/trait.FromRequest.html#foreign-impls"><code>FromRequest</code> trait</a>.
Then <code>from_request()</code> get called on returned object. And finally
result of the <code>from_request()</code> call get converted to <code>Reply</code> object.</p>
<p>By default actix provides several <code>FromRequest</code> implementations for some standard types,
like <code>&amp;'static str</code>, <code>String</code>, etc.
For complete list of implementations check
<a href="../actix_web/trait.FromRequest.html#foreign-impls">FromRequest documentation</a>.</p>
<p>Examples of valid handlers:</p>
<pre><code class="language-rust ignore">fn index(req: HttpRequest) -&gt; &amp;'static str {
    &quot;Hello world!&quot;
}
</code></pre>
<pre><code class="language-rust ignore">fn index(req: HttpRequest) -&gt; String {
    &quot;Hello world!&quot;.to_owned()
}
</code></pre>
<pre><code class="language-rust ignore">fn index(req: HttpRequest) -&gt; Bytes {
    Bytes::from_static(&quot;Hello world!&quot;)
}
</code></pre>
<pre><code class="language-rust ignore">fn index(req: HttpRequest) -&gt; Box&lt;Future&lt;Item=HttpResponse, Error=Error&gt;&gt; {
    ...
}
</code></pre>
<a class="header" href="print.html#response-with-custom-type" id="response-with-custom-type"><h2>Response with custom type</h2></a>
<p>To return custom type directly from handler function <code>FromResponse</code> trait should be
implemented for this type. Let's create response for custom type that
serializes to <code>application/json</code> response:</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix;
# extern crate actix_web;
extern crate serde;
extern crate serde_json;
#[macro_use] extern crate serde_derive;
use actix_web::*;

#[derive(Serialize)]
struct MyObj {
    name: &amp;'static str,
}

/// we have to convert Error into HttpResponse as well
impl FromRequest for MyObj {
    type Item = HttpResponse;
    type Error = Error;

    fn from_request(self, req: HttpRequest) -&gt; Result&lt;HttpResponse&gt; {
        let body = serde_json::to_string(&amp;self)?;

        // Create response and set content type
        Ok(HttpResponse::Ok()
            .content_type(&quot;application/json&quot;)
            .body(body)?)
    }
}

fn index(req: HttpRequest) -&gt; MyObj {
    MyObj{name: &quot;user&quot;}
}

fn main() {
    let sys = actix::System::new(&quot;example&quot;);

    HttpServer::new(
        Application::new(&quot;/&quot;)
            .resource(&quot;/&quot;, |r| r.method(Method::GET).f(index)))
        .serve::&lt;_, ()&gt;(&quot;127.0.0.1:8088&quot;).unwrap();

    println!(&quot;Started http server: 127.0.0.1:8088&quot;);
#    actix::Arbiter::system().send(actix::msgs::SystemExit(0));
    let _ = sys.run();
}
</code></pre></pre>
<a class="header" href="print.html#async-handlers" id="async-handlers"><h2>Async handlers</h2></a>
<p>There are two different types of async handlers.</p>
<p>Response object could be generated asynchronously. In this case handle must
return <code>Future</code> object that resolves to <code>HttpResponse</code>, i.e:</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix_web;
# extern crate futures;
# extern crate bytes;
# use actix_web::*;
# use bytes::Bytes;
# use futures::stream::once;
# use futures::future::{FutureResult, result};
fn index(req: HttpRequest) -&gt; FutureResult&lt;HttpResponse, Error&gt; {

    result(HttpResponse::Ok()
           .content_type(&quot;text/html&quot;)
           .body(format!(&quot;Hello!&quot;))
           .map_err(|e| e.into()))
}

fn main() {
    Application::new(&quot;/&quot;)
        .resource(&quot;/async&quot;, |r| r.route().a(index))
        .finish();
}
</code></pre></pre>
<p>Or response body can be generated asynchronously. In this case body
must implement stream trait <code>Stream&lt;Item=Bytes, Error=Error&gt;</code>, i.e:</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix_web;
# extern crate futures;
# extern crate bytes;
# use actix_web::*;
# use bytes::Bytes;
# use futures::stream::once;
fn index(req: HttpRequest) -&gt; HttpResponse {
    let body = once(Ok(Bytes::from_static(b&quot;test&quot;)));

    HttpResponse::Ok()
       .content_type(&quot;application/json&quot;)
       .body(Body::Streaming(Box::new(body))).unwrap()
}

fn main() {
    Application::new(&quot;/&quot;)
        .resource(&quot;/async&quot;, |r| r.f(index))
        .finish();
}
</code></pre></pre>
<p>Both methods could be combined. (i.e Async response with streaming body)</p>
<a class="header" href="print.html#errors" id="errors"><h1>Errors</h1></a>
<p>Actix uses <a href="../actix_web/error/struct.Error.html"><code>Error</code> type</a>
and <a href="../actix_web/error/trait.ResponseError.html"><code>ResponseError</code> trait</a>
for handling handler's errors.
Any error that implements <code>ResponseError</code> trait can be returned as error value.
<em>Handler</em> can return <em>Result</em> object, actix by default provides
<code>FromRequest</code> implemenation for compatible result object. Here is implementation
definition:</p>
<pre><code class="language-rust ignore">impl&lt;T: FromRequest, E: Into&lt;Error&gt;&gt; FromRequest for Result&lt;T, E&gt;
</code></pre>
<p>And any error that implements <code>ResponseError</code> can be converted into <code>Error</code> object.
For example if <em>handler</em> function returns <code>io::Error</code>, it would be converted
into <code>HTTPInternalServerError</code> response. Implementation for <code>io::Error</code> is provided
by default.</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix_web;
# use actix_web::*;
use std::io;

fn index(req: HttpRequest) -&gt; io::Result&lt;fs::NamedFile&gt; {
    Ok(fs::NamedFile::open(&quot;static/index.html&quot;)?)
}
#
# fn main() {
#     Application::new(&quot;/&quot;)
#         .resource(r&quot;/a/index.html&quot;, |r| r.f(index))
#         .finish();
# }
</code></pre></pre>
<a class="header" href="print.html#custom-error-response" id="custom-error-response"><h2>Custom error response</h2></a>
<p>To add support for custom errors all we need to do just implement <code>ResponseError</code> trait.
<code>ResponseError</code> trait has default implementation for <code>error_response()</code> method, it
generates <em>500</em> response.</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix_web;
#[macro_use] extern crate failure;
use actix_web::*;

#[derive(Fail, Debug)]
#[fail(display=&quot;my error&quot;)]
struct MyError {
   name: &amp;'static str
}

impl error::ResponseError for MyError {}

fn index(req: HttpRequest) -&gt; Result&lt;&amp;'static str, MyError&gt; {
    Err(MyError{name: &quot;test&quot;})
}
#
# fn main() {
#     Application::new(&quot;/&quot;)
#         .resource(r&quot;/a/index.html&quot;, |r| r.f(index))
#         .finish();
# }
</code></pre></pre>
<p>In this example <em>index</em> handler will always return <em>500</em> response. But it is easy
to return different responses.</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix_web;
#[macro_use] extern crate failure;
use actix_web::*;

#[derive(Fail, Debug)]
enum MyError {
   #[fail(display=&quot;internal error&quot;)]
   InternalError,
   #[fail(display=&quot;bad request&quot;)]
   BadClientData,
   #[fail(display=&quot;timeout&quot;)]
   Timeout,
}

impl error::ResponseError for MyError {
    fn error_response(&amp;self) -&gt; HttpResponse {
       match *self {
          MyError::InternalError =&gt; HttpResponse::new(
              StatusCode::INTERNAL_SERVER_ERROR, Body::Empty),
          MyError::BadClientData =&gt; HttpResponse::new(
              StatusCode::BAD_REQUEST, Body::Empty),
          MyError::Timeout =&gt; HttpResponse::new(
              StatusCode::GATEWAY_TIMEOUT, Body::Empty),
       }
    }
}

fn index(req: HttpRequest) -&gt; Result&lt;&amp;'static str, MyError&gt; {
    Err(MyError::BadClientData)
}
#
# fn main() {
#     Application::new(&quot;/&quot;)
#         .resource(r&quot;/a/index.html&quot;, |r| r.f(index))
#         .finish();
# }
</code></pre></pre>
<a class="header" href="print.html#error-helpers" id="error-helpers"><h2>Error helpers</h2></a>
<p>Actix provides set of error helper types. It is possible to use them to generate
specific error response. We can use helper types for first example with custom error.</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix_web;
#[macro_use] extern crate failure;
use actix_web::*;

#[derive(Debug)]
struct MyError {
   name: &amp;'static str
}

fn index(req: HttpRequest) -&gt; Result&lt;&amp;'static str&gt; {
    let result: Result&lt;&amp;'static str, MyError&gt; = Err(MyError{name: &quot;test&quot;});
    
    Ok(result.map_err(error::ErrorBadRequest)?)
}
# fn main() {
#     Application::new(&quot;/&quot;)
#         .resource(r&quot;/a/index.html&quot;, |r| r.f(index))
#         .finish();
# }
</code></pre></pre>
<p>In this example <em>BAD REQUEST</em> response get generated for <code>MYError</code> error.</p>
<a class="header" href="print.html#application-state" id="application-state"><h1>Application state</h1></a>
<p>Application state is shared with all routes and resources within same application.
State could be accessed with <code>HttpRequest::state()</code> method as a read-only item
but interior mutability pattern with <code>RefCell</code> could be used to archive state mutability.
State could be accessed with <code>HttpContext::state()</code> in case of http actor.
State also available to route matching predicates. State is not available
to application middlewares, middlewares receives <code>HttpRequest&lt;()&gt;</code> object.</p>
<p>Let's write simple application that uses shared state. We are going to store requests count
in the state:</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix;
# extern crate actix_web;
# 
use actix_web::*;
use std::cell::Cell;

// This struct represents state
struct AppState {
    counter: Cell&lt;usize&gt;,
}

fn index(req: HttpRequest&lt;AppState&gt;) -&gt; String {
    let count = req.state().counter.get() + 1; // &lt;- get count
    req.state().counter.set(count);            // &lt;- store new count in state

    format!(&quot;Request number: {}&quot;, count)       // &lt;- response with count
}

fn main() {
    Application::with_state(&quot;/&quot;, AppState{counter: Cell::new(0)})
        .resource(&quot;/&quot;, |r| r.method(Method::GET).f(index))
        .finish();
}
</code></pre></pre>
<a class="header" href="print.html#resources-and-routes" id="resources-and-routes"><h1>Resources and Routes</h1></a>
<p>All resources and routes register for specific application.
Application routes incoming requests based on route criteria which is defined during
resource registration or path prefix for simple handlers.
Internally <em>router</em> is a list of <em>resources</em>. Resource is an entry in <em>route table</em>
which corresponds to requested URL.</p>
<p>Prefix handler:</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix_web;
# use actix_web::*;
# 
fn index(req: HttpRequest) -&gt; HttpResponse {
   unimplemented!()
}

fn main() {
    Application::new(&quot;/&quot;)
        .resource(&quot;/prefix&quot;, |r| r.f(index))
        .finish();
}
</code></pre></pre>
<p>In this example <code>index</code> get called for any url which starts with <code>/prefix</code>.</p>
<p>Application prefix combines with handler prefix i.e</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix_web;
# use actix_web::*;
# 
fn index(req: HttpRequest) -&gt; HttpResponse {
   unimplemented!()
}

fn main() {
    Application::new(&quot;/app&quot;)
        .resource(&quot;/prefix&quot;, |r| r.f(index))
        .finish();
}
</code></pre></pre>
<p>In this example <code>index</code> get called for any url which starts with<code>/app/prefix</code>.</p>
<p>Resource contains set of route for same endpoint. Route corresponds to handling
<em>HTTP method</em> by calling <em>web handler</em>. Resource select route based on <em>http method</em>,
if no route could be matched default response <code>HTTPMethodNotAllowed</code> get resturned.</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix_web;
# use actix_web::*;
# 
fn main() {
    Application::new(&quot;/&quot;)
        .resource(&quot;/prefix&quot;, |r| {
           r.method(Method::GET).h(httpcodes::HTTPOk);
           r.method(Method::POST).h(httpcodes::HTTPForbidden);
        })
        .finish();
}
</code></pre></pre>
<p><a href="../actix_web/dev/struct.ApplicationBuilder.html#method.resource"><code>ApplicationBuilder::resource()</code> method</a>
accepts configuration function, resource could be configured at once.
Check <a href="../actix-web/target/doc/actix_web/struct.Resource.html"><code>Resource</code></a> documentation
for more information.</p>
<a class="header" href="print.html#variable-resources" id="variable-resources"><h2>Variable resources</h2></a>
<p>Resource may have <em>variable path</em>also. For instance, a resource with the
path '/a/{name}/c' would match all incoming requests with paths such
as '/a/b/c', '/a/1/c', and '/a/etc/c'.</p>
<p>A <em>variable part</em> is specified in the form {identifier}, where the identifier can be
used later in a request handler to access the matched value for that part. This is
done by looking up the identifier in the <code>HttpRequest.match_info</code> object:</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix_web;
use actix_web::*;

fn index(req: HttpRequest) -&gt; String {
    format!(&quot;Hello, {}&quot;, &amp;req.match_info()[&quot;name&quot;])
}

fn main() {
    Application::new(&quot;/&quot;)
        .resource(&quot;/{name}&quot;, |r| r.method(Method::GET).f(index))
        .finish();
}
</code></pre></pre>
<p>By default, each part matches the regular expression <code>[^{}/]+</code>.</p>
<p>You can also specify a custom regex in the form <code>{identifier:regex}</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix_web;
# use actix_web::*;
# fn index(req: HttpRequest) -&gt; String {
#     format!(&quot;Hello, {}&quot;, &amp;req.match_info()[&quot;name&quot;])
# }
# 
fn main() {
    Application::new(&quot;/&quot;)
        .resource(r&quot;{name:\d+}&quot;, |r| r.method(Method::GET).f(index))
        .finish();
}
</code></pre></pre>
<p>Any matched parameter can be deserialized into specific type if this type
implements <code>FromParam</code> trait. For example most of standard integer types
implements <code>FromParam</code> trait. i.e.:</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix_web;
use actix_web::*;

fn index(req: HttpRequest) -&gt; Result&lt;String&gt; {
    let v1: u8 = req.match_info().query(&quot;v1&quot;)?;
    let v2: u8 = req.match_info().query(&quot;v2&quot;)?;
    Ok(format!(&quot;Values {} {}&quot;, v1, v2))
}

fn main() {
    Application::new(&quot;/&quot;)
        .resource(r&quot;/a/{v1}/{v2}/&quot;, |r| r.f(index))
        .finish();
}
</code></pre></pre>
<p>For this example for path '/a/1/2/', values v1 and v2 will resolve to &quot;1&quot; and &quot;2&quot;.</p>
<p>It is possible to match path tail with custom <code>.*</code> regex.</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix_web;
# use actix_web::*;
# 
# fn index(req: HttpRequest) -&gt; HttpResponse {
#    unimplemented!()
# }
fn main() {
    Application::new(&quot;/&quot;)
        .resource(r&quot;/test/{tail:.*}&quot;, |r| r.method(Method::GET).f(index))
        .finish();
}
</code></pre></pre>
<p>Above example would match all incoming requests with path such as
'/test/b/c', '/test/index.html', and '/test/etc/test'.</p>
<p>It is possible to create a <code>PathBuf</code> from a tail path parameter. The returned <code>PathBuf</code> is
percent-decoded. If a segment is equal to &quot;..&quot;, the previous segment (if
any) is skipped.</p>
<p>For security purposes, if a segment meets any of the following conditions,
an <code>Err</code> is returned indicating the condition met:</p>
<ul>
<li>Decoded segment starts with any of: <code>.</code> (except <code>..</code>), <code>*</code></li>
<li>Decoded segment ends with any of: <code>:</code>, <code>&gt;</code>, <code>&lt;</code></li>
<li>Decoded segment contains any of: <code>/</code></li>
<li>On Windows, decoded segment contains any of: ''</li>
<li>Percent-encoding results in invalid UTF8.</li>
</ul>
<p>As a result of these conditions, a <code>PathBuf</code> parsed from request path parameter is
safe to interpolate within, or use as a suffix of, a path without additional checks.</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix_web;
use actix_web::*;
use std::path::PathBuf;

fn index(req: HttpRequest) -&gt; Result&lt;String&gt; {
    let path: PathBuf = req.match_info().query(&quot;tail&quot;)?;
    Ok(format!(&quot;Path {:?}&quot;, path))
}

fn main() {
    Application::new(&quot;/&quot;)
        .resource(r&quot;/a/{tail:.*}&quot;, |r| r.method(Method::GET).f(index))
        .finish();
}
</code></pre></pre>
<a class="header" href="print.html#httprequest--httpresponse" id="httprequest--httpresponse"><h1>HttpRequest &amp; HttpResponse</h1></a>
<a class="header" href="print.html#response" id="response"><h2>Response</h2></a>
<p>Builder-like patter is used to construct an instance of <code>HttpResponse</code>.
<code>HttpResponse</code> provides several method that returns <code>HttpResponseBuilder</code> instance,
which is implements various convinience methods that helps build response.
Check <a href="../actix_web/dev/struct.HttpResponseBuilder.html">documentation</a>
for type description. Methods <code>.body</code>, <code>.finish</code>, <code>.json</code> finalizes response creation,
if this methods get call for the same builder instance, builder will panic.</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix_web;
use actix_web::*;
use actix_web::headers::ContentEncoding;

fn index(req: HttpRequest) -&gt; HttpResponse {
    HttpResponse::Ok()
        .content_encoding(ContentEncoding::Br)
        .content_type(&quot;plain/text&quot;)
        .header(&quot;X-Hdr&quot;, &quot;sample&quot;)
        .body(&quot;data&quot;).unwrap()
}
# fn main() {}
</code></pre></pre>
<a class="header" href="print.html#content-encoding" id="content-encoding"><h2>Content encoding</h2></a>
<p>Actix automatically <em>compress</em>/<em>decompress</em> payload. Following codecs are supported:</p>
<ul>
<li>Brotli</li>
<li>Gzip</li>
<li>Deflate</li>
<li>Identity</li>
</ul>
<p>If request headers contains <code>Content-Encoding</code> header, request payload get decompressed
according to header value. Multiple codecs are not supported, i.e: <code>Content-Encoding: br, gzip</code>.</p>
<p>Response payload get compressed based on <em>content_encoding</em> parameter.
By default <code>ContentEncoding::Auto</code> is used. If <code>ContentEncoding::Auto</code> is selected
then compression depends on request's <code>Accept-Encoding</code> header.
<code>ContentEncoding::Identity</code> could be used to disable compression.
If other content encoding is selected the compression is enforced for this codec. For example,
to enable <code>brotli</code> response's body compression use <code>ContentEncoding::Br</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix_web;
use actix_web::*;
use actix_web::headers::ContentEncoding;

fn index(req: HttpRequest) -&gt; HttpResponse {
    HttpResponse::Ok()
        .content_encoding(ContentEncoding::Br)
        .body(&quot;data&quot;).unwrap()
}
# fn main() {}
</code></pre></pre>
<a class="header" href="print.html#json-response" id="json-response"><h2>JSON Response</h2></a>
<p>The <code>Json</code> type allows you to respond with well-formed JSON data: simply return a value of
type Json<T> where T is the type of a structure to serialize into <em>JSON</em>. The
type <code>T</code> must implement the <code>Serialize</code> trait from <em>serde</em>.</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix_web;
#[macro_use] extern crate serde_derive;
use actix_web::*;

#[derive(Serialize)]
struct MyObj {
    name: String,
}

fn index(req: HttpRequest) -&gt; Result&lt;Json&lt;MyObj&gt;&gt; {
    Ok(Json(MyObj{name: req.match_info().query(&quot;name&quot;)?}))
}

fn main() {
    Application::new(&quot;/&quot;)
        .resource(r&quot;/a/{name}&quot;, |r| r.method(Method::GET).f(index))
        .finish();
}
</code></pre></pre>
<a class="header" href="print.html#websockets" id="websockets"><h1>WebSockets</h1></a>
<a class="header" href="print.html#middlewares" id="middlewares"><h1>Middlewares</h1></a>
<a class="header" href="print.html#logging" id="logging"><h2>Logging</h2></a>
<p>Logging is implemented as middleware. Middlewares get executed in same order as registraton order.
It is common to register logging middleware as first middleware for application.
Logging middleware has to be registered for each application.</p>
<a class="header" href="print.html#usage" id="usage"><h3>Usage</h3></a>
<p>Create <code>Logger</code> middlewares with the specified <code>format</code>.
Default <code>Logger</code> could be created with <code>default</code> method, it uses the default format:</p>
<pre><code class="language-ignore">  %a %t &quot;%r&quot; %s %b &quot;%{Referrer}i&quot; &quot;%{User-Agent}i&quot; %T
</code></pre>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix_web;
use actix_web::Application;
use actix_web::middlewares::Logger;

fn main() {
    Application::new(&quot;/&quot;)
       .middleware(Logger::default())
       .middleware(Logger::new(&quot;%a %{User-Agent}i&quot;))
       .finish();
}
</code></pre></pre>
<p>Here is example of default logging format:</p>
<pre><code>INFO:actix_web::middlewares::logger: 127.0.0.1:59934 [02/Dec/2017:00:21:43 -0800] &quot;GET / HTTP/1.1&quot; 302 0 &quot;-&quot; &quot;curl/7.54.0&quot; 0.000397
INFO:actix_web::middlewares::logger: 127.0.0.1:59947 [02/Dec/2017:00:22:40 -0800] &quot;GET /index.html HTTP/1.1&quot; 200 0 &quot;-&quot; &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:57.0) Gecko/20100101 Firefox/57.0&quot; 0.000646
</code></pre>
<a class="header" href="print.html#format" id="format"><h3>Format</h3></a>
<p><code>%%</code>  The percent sign</p>
<p><code>%a</code>  Remote IP-address (IP-address of proxy if using reverse proxy)</p>
<p><code>%t</code>  Time when the request was started to process</p>
<p><code>%P</code>  The process ID of the child that serviced the request</p>
<p><code>%r</code>  First line of request</p>
<p><code>%s</code>  Response status code</p>
<p><code>%b</code>  Size of response in bytes, including HTTP headers</p>
<p><code>%T</code>  Time taken to serve the request, in seconds with floating fraction in .06f format</p>
<p><code>%D</code>  Time taken to serve the request, in milliseconds</p>
<p><code>%{FOO}i</code>  request.headers['FOO']</p>
<p><code>%{FOO}o</code>  response.headers['FOO']</p>
<p><code>%{FOO}e</code>  os.environ['FOO']</p>
<a class="header" href="print.html#default-headers" id="default-headers"><h2>Default headers</h2></a>
<p>Tto set default response headers <code>DefaultHeaders</code> middleware could be used.
<em>DefaultHeaders</em> middleware does not set header if response headers already contains it.</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix_web;
use actix_web::*;

fn main() {
    let app = Application::new(&quot;/&quot;)
        .middleware(
            middlewares::DefaultHeaders::build()
                .header(&quot;X-Version&quot;, &quot;0.2&quot;)
                .finish())
        .resource(&quot;/test&quot;, |r| {
             r.method(Method::GET).f(|req| httpcodes::HTTPOk);
             r.method(Method::HEAD).f(|req| httpcodes::HTTPMethodNotAllowed);
        })
       .finish();
}
</code></pre></pre>
<a class="header" href="print.html#user-sessions" id="user-sessions"><h2>User sessions</h2></a>
<a class="header" href="print.html#static-file-handling" id="static-file-handling"><h1>Static file handling</h1></a>
<a class="header" href="print.html#individual-file" id="individual-file"><h2>Individual file</h2></a>
<p>It is possible to serve static files with custom path pattern and <code>NamedFile</code>. To
match path tail we can use <code>[.*]</code> regex.</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix_web;
use actix_web::*;
use std::path::PathBuf;

fn index(req: HttpRequest) -&gt; Result&lt;fs::NamedFile&gt; {
    let path: PathBuf = req.match_info().query(&quot;tail&quot;)?;
    Ok(fs::NamedFile::open(path)?)
}

fn main() {
    Application::new(&quot;/&quot;)
        .resource(r&quot;/a/{tail:.*}&quot;, |r| r.method(Method::GET).f(index))
        .finish();
}
</code></pre></pre>
<a class="header" href="print.html#directory" id="directory"><h2>Directory</h2></a>
<p>To serve files from specific directory and sub-directories <code>StaticFiles</code> could be used.
<code>StaticFiles</code> could be registered with <code>Application::resource</code> method.
<code>StaticFiles</code> requires tail named path expression for resource registration.
And this name has to be used in <code>StaticFile</code> constructor.</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate actix_web;
use actix_web::*;

fn main() {
    Application::new(&quot;/&quot;)
        .resource(&quot;/static/{tail:.*}&quot;, |r| r.h(fs::StaticFiles::new(&quot;tail&quot;, &quot;.&quot;, true)))
        .finish();
}
</code></pre></pre>
<p>First parameter is a name of path pattern. Second parameter is a base directory.
Third parameter is <em>show_index</em>, if it is set to <em>true</em>
directory listing would be returned for directories, if it is set to <em>false</em>
then <em>404 Not Found</em> would be returned instead of directory listing.</p>
<a class="header" href="print.html#http2" id="http2"><h1>HTTP/2</h1></a>
<p>Actix web automatically upgrades connection to <em>HTTP/2</em> if possible.</p>
<a class="header" href="print.html#negotiation" id="negotiation"><h2>Negotiation</h2></a>
<p><em>HTTP/2</em> protocol over tls without prior knowlage requires
<a href="https://tools.ietf.org/html/rfc7301">tls alpn</a>. At the moment only
<code>rust-openssl</code> has support. Turn on <code>alpn</code> feature to enable <code>alpn</code> negotiation.
With enable <code>alpn</code> feature <code>HttpServer</code> provides
<a href="../actix_web/struct.HttpServer.html#method.serve_tls">serve_tls</a> method.</p>
<pre><code class="language-toml">[dependencies]
actix-web = { git = &quot;https://github.com/actix/actix-web&quot;, features=[&quot;alpn&quot;] }
</code></pre>
<pre><code class="language-rust ignore">use std::fs::File;
use actix_web::*;

fn main() {
    let mut file = File::open(&quot;identity.pfx&quot;).unwrap();
    let mut pkcs12 = vec![];
    file.read_to_end(&amp;mut pkcs12).unwrap();
    let pkcs12 = Pkcs12::from_der(&amp;pkcs12).unwrap().parse(&quot;12345&quot;).unwrap();

    HttpServer::new(
        Application::new(&quot;/&quot;)
            .resource(&quot;/index.html&quot;, |r| r.f(index))
        .serve_tls::&lt;_, ()&gt;(&quot;127.0.0.1:8080&quot;, pkcs12).unwrap();
}
</code></pre>
<p>Upgrade to <em>HTTP/2</em> schema described in
<a href="https://http2.github.io/http2-spec/#rfc.section.3.2">rfc section 3.2</a> is not supported.
Starting <em>HTTP/2</em> with prior knowledge is supported for both clear text connection
and tls connection. <a href="https://http2.github.io/http2-spec/#rfc.section.3.4">rfc section 3.4</a></p>
<p>Please check <a href="https://github.com/actix/actix-web/tree/master/examples/tls">example</a>
for concrete example.</p>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        
        <!-- Google Analytics Tag -->
        <script>
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is 
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-110322332-1', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        

        
        <script>
            $(document).ready(function() {
                window.print();
            })
        </script>
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
